## 🚀 프로젝트 Sunfish: 최종 요약 및 구현 가이드
Sunfish는 독창적인 가설에 기반한 유전자 주석(Gene Annotation) 도구입니다. 기존 C 코드를 확장하여 train과 predict 두 가지 모드로 작동하는 프로그램을 개발하는 것이 목표입니다.

🎯 핵심 가설: 통계적 확률 vs. 이론적 확률
이 프로젝트의 모든 로직은 다음 가설을 검증하는 데서 출발합니다.

"하나의 펩타이드 서열은, 그 서열을 구성하는 모든 아미노산에 대해 통계적 존재 확률이 이론적 존재 확률보다 크거나 같을 때에만 생물학적으로 유효하다."

통계적 확률 (P
stat
​
 )

의미: 이미 알려진 전체 유전자(펩타이드)들의 아미노산 분포를 바탕으로, 특정 펩타이드의 등장을 예측한 확률.

계산: 로지스틱 회귀 모델 M에 해당 펩타이드의 아미노산 카운트 벡터를 입력하여 얻는 값. P_stat = sigmoid(W • X)

이론적 확률 (P
theory
​
 )

의미: 해당 펩타이드 내부의 아미노산 구성 비율만으로 계산한 확률. 외부 정보 없이, 그 펩타이드가 무작위로 생성되었을 때 특정 아미노산이 최소 한 번 포함될 확률.

계산: P_theory = 1 - (1 - q)^L

L: 해당 펩타이드의 전체 길이

q: 해당 펩타이드 내 특정 아미노산의 비율 (해당 아미노산 개수 / L)

🧬 프로그램 구조 및 모드
sunfish는 두 가지 주요 모드로 작동합니다.

1. 학습 모드: sunfish train
입력:

train.fasta: 레퍼런스 유전체 서열

train.gff: 해당 유전체의 검증된 유전자 주석 정보

작업 흐름:

데이터 준비: GFF 파일의 CDS 정보를 바탕으로 부모 ID가 같은 엑손들을 그룹화합니다. FASTA 파일에서 해당 위치의 DNA 서열을 가져와, 스트랜드(strand)를 고려하여 엑손들을 이어 붙입니다(splicing).

펩타이드 추출: 이어 붙인 CDS 서열을 아미노산 서열(펩타이드)로 번역하고, 각 펩타이드의 20가지 아미노산 개수를 카운트합니다.

모델 학습 (Leave-One-Out 방식): 20개의 아미노산 각각에 대해 별도의 로지스틱 회귀 모델을 학습합니다.

핵심 아이디어: 특정 아미노산(AA_k)의 존재 여부를 예측할 때, 예측 대상 펩타이드를 제외한 나머지 전체 펩타이드들의 아미노산 분포를 학습 데이터로 사용합니다.

Target (y): peptide_i에 AA_k가 있으면 1, 없으면 0.

Feature (X): peptide_i에 대한 학습 데이터는 (전체 펩타이드들의 AA_k 총합) - (peptide_i의 AA_k 개수) 입니다.

출력: 학습된 20개 모델의 계수(coefficients)를 sunfish.model 파일에 저장합니다.

2. 예측 모드: sunfish predict
입력:

target.fasta: 분석할 새로운 유전체 서열

sunfish.model: train 모드에서 생성된 모델 파일

작업 흐름:

모델 로딩: sunfish.model 파일에서 20개 모델의 계수를 불러옵니다.

후보 펩타이드 생성:

FASTA 서열의 정방향(forward) 및 역상보(reverse-complement) 가닥을 모두 탐색합니다.

큐(Queue) 기반의 반복 알고리즘을 사용하여 가능한 모든 코딩 서열(CDS)을 찾습니다.

ATG (개시코돈)에서 탐색 시작

GT-AG (캐노니컬 스플라이싱 시그널)를 이용해 엑손 연결

TAA, TGA, TAG (종결코돈)에서 탐색 종료

후보 검증: 생성된 각 후보 펩타이드에 대해 핵심 가설을 적용합니다.

펩타이드의 아미노산 카운트 벡터를 준비합니다.

20개 아미노산 각각에 대해 P_stat와 P_theory를 계산합니다.

모든 아미노산에 대해 P_stat >= P_theory 조건을 만족하는지 확인합니다.

출력: 검증을 통과한 "Valid" 펩타이드만 그 위치 정보(엑손 좌표, 스트랜드 등)를 GFF3 형식으로 표준 출력(stdout)에 출력합니다.

📝 구현을 위한 데이터 구조 (C언어 struct)
구현 시 아래와 같은 핵심 데이터 구조가 필요합니다.

FastaData / FastaRecord: FASTA 파일의 ID와 서열을 저장.

CdsGroup / Exon: GFF의 CDS 정보를 부모 ID 기준으로 그룹화하고, 각 엑손의 좌표를 저장.

PeptideInfo: 학습 단계에서 사용할 구조체. 번역된 펩타이드 서열과 20개 아미노산 카운트 배열을 저장.

CandidateCDS: 예측 단계에서 찾은 후보 유전자. 서열 ID, 스트랜드, 엑손 좌표 리스트를 저장.

🛠️ 개발 단계 체크리스트
[기반 설정] main 함수를 train/predict 모드 분기점으로 리팩토링.

[유틸리티 구현] FASTA/GFF 파서, 서열 번역, 역상보 변환 등 핵심 헬퍼 함수 작성.

[train 모드 구현] GFF/FASTA 데이터로 펩타이드를 추출하고, "Leave-One-Out" 방식의 학습 로직을 구현.

[predict 모드 구현 - 1] 가장 복잡한 부분: 스플라이싱을 고려하는 큐 기반 후보 CDS 생성 알고리즘 구현.

[predict 모드 구현 - 2] 후보 펩타이드에 대한 P_stat vs P_theory 검증 로직 및 GFF3 출력부 구현.

[통합 및 테스트] 전체 코드를 컴파일하고, 샘플 데이터로 각 모드의 정상 작동을 확인.